#!/usr/bin/env python

#This script applies patches to an XML file, where the patches themselves
#are specified in XML in a separate file.  This patch file can have any root
#element name, and uses XML attributes to specify if the elements in the file
#should replace existing elements or add new ones.  An XPath attribute is
#used to specify where the fix should be applied.
#This script was written for patching XML generated by ServerWiz2, but should
#work on any XML assuming it doesn't use the 'type, 'key', or 'xpath'
#attributes in a way that the script would try to use them instead.
#
# It can apply patches in 5 ways:
#
# 1) Add an element:
#    Put in the element to add, along with the type='add' attribute
#    and an xpath attribute specifying where the new element should go.
#
#     <enumerationType type='add' xpath="./">
#       <id>MY_TYPE</id>
#     </enumerationType>
#
#     This will add a new enumerationType element child to root element
#
# 2) Replace an element:
#    Put in the new element, with the type='replace' attribute
#    and the XPath of the element you want to replace.
#
#     <enumerator type='replace'
#               xpath="enumerationType/[id='TYPE']/enumerator[name='XBUS']">
#       <name>XBUS</name>
#       <value>the new XBUS value</value>
#     </enumerator>
#
#    This will replace the enumerator element with name XBUS under the
#    TYPE enumerationType
#
# 3) Remove an element:
#    Put in the element to remove, with the type='remove' attribute and
#    the XPath of the element you want to remove. The full element contents
#    don't need to be specified, as the XPath is what locates the element.
#
#    <enumerator type='remove'
#                xpath='enumerationType[id='TYPE]/enumerator[name='DIMM']>
#    </enumerator>
#
# 4) Add child elements to a specific element.  Useful when adding several
#    child elements at once.
#
#    Use a type attribute of 'add-child' and specify the target parent with
#    the xpath attribute.
#
#     <enumerationType type="add-child" xpath="enumerationType/[id='TYPE']">
#       <enumerator>
#         <name>MY_NEW_ENUMERATOR</name>
#         <value>23</value>
#       </enumerator>
#       <enumerator>
#         <name>ANOTHER_NEW_ENUMERATOR</name>
#         <value>99</value>
#       </enumerator>
#     </enumerationType>
#
#     This will add 2 new <enumerator> elements to the enumerationType
#     element with ID TYPE.
#
# 5) Replace a child element inside another element, useful when replacing
#    several child elements of the same parent at once.
#
#    Use a type attribute of 'replace-child' and the xpath attribute
#    as described above, and also use the key attribute to specify which
#    element should be used to match on so the replace can be done.
#
#     <enumerationType type="replace-child"
#                      key="name"
#                      xpath="enumerationType/[id='TYPE']">
#       <enumerator>
#         <name>OLD_ENUMERATOR</name>
#         <value>newvalue</value>
#       </enumerator>
#       <enumerator>
#         <name>ANOTHER_OLD_ENUMERATOR</name>
#         <value>anothernewvalue</value>
#       </enumerator>
#     </enumerationType>
#
#     This will replace the <enumerator> elements with the names of
#     OLD_ENUMERATOR and ANOTHER_OLD_ENUMERATOR with the <enumerator>
#     elements specified, inside of the enumerationType element with
#     ID TYPE.

from lxml import etree
import sys
import argparse


def printError(msg):
    print "\nERROR:  " + msg + "\n"


def deleteAttrs(element, attrs):
    for a in attrs:
        try:
            del element.attrib[a]
        except:
            pass


parser = argparse.ArgumentParser("Applies fixes to XML files")
parser.add_argument("-x", dest='mrwXML', help='The MRW XML file')
parser.add_argument("-p", dest='patchXML', help='The patch XML file')
parser.add_argument("-o", dest='outputXML', help='The output XML file')
args = parser.parse_args()

if args.mrwXML is None or args.patchXML is None or args.outputXML is None:
    parser.print_usage()
    sys.exit(-1)

rc = 0
patchNum = 0
patchTree = etree.parse(args.patchXML)
patchRoot = patchTree.getroot()
tree = etree.parse(args.mrwXML)
root = tree.getroot()

for node in patchRoot:
    if (node.tag is etree.PI) or (node.tag is etree.Comment):
        continue

    xpath = node.get('xpath', None)
    patchType = node.get('type', 'add')
    patchKey = node.get('key', None)
    deleteAttrs(node, ['xpath', 'type', 'key'])

    if xpath is None:
        printError("No XPath attribute found for patch " + str(patchNum))
    else:
        target = tree.find(xpath)

        if target is None:
            printError("Patch " + str(patchNum) + ": Could not find XPath "
                       "target " + xpath)
            rc = -1
        else:
            print "Patch " + str(patchNum) + ":"

            if patchType == "add":

                print("  Adding element " + target.tag + " to " + xpath)

                #The ServerWiz API is dependent on ordering for the elements
                #at the root node, so make sure they get added at the end
                if (xpath == "./") or (xpath == "/"):
                    root.append(node)
                else:
                    target.append(node)

            elif patchType == "remove":

                print("  Removing element " + xpath)
                parent = target.find("..")
                if parent is None:
                    printError("Could not find parent of " + xpath +
                               " so can't remove this element")
                    rc = -1
                else:
                    parent.remove(target)

            elif patchType == "replace":

                print("  Replacing element " + xpath)
                parent = target.find("..")
                if parent is None:
                    printError("Could not find parent of " + xpath +
                               " so can't replace this element")
                    rc = -1
                else:
                    parent.remove(target)
                    parent.append(node)

            elif patchType == "add-child":

                for child in node:
                    print("  Adding a '" + child.tag + "' child element to " +
                          xpath)
                    target.append(child)

            elif patchType == "replace-child":

                if patchKey is not None:
                    updates = []
                    for child in node:
                        #Use the key to figure out which element to replace
                        keyElement = child.find(patchKey)
                        for targetChild in target:
                            for grandchild in targetChild:
                                if (grandchild.tag == patchKey) and \
                                   (grandchild.text == keyElement.text):
                                    update = {}
                                    update['remove'] = targetChild
                                    update['add'] = child
                                    updates.append(update)

                    for update in updates:
                        print("  Replacing a '" + update['remove'].tag +
                              "' element in path " + xpath)
                        target.remove(update['remove'])
                        target.append(update['add'])

                else:
                    printError("Patch type is replace-child, but 'key' "
                               + "attribute isn't set")
                    rc = -1

    patchNum = patchNum + 1

tree.write(args.outputXML)
print "\nCreated patched file " + args.outputXML

sys.exit(rc)
